void extractKeypoints_harris_and_3dsc(
        pcl::PointCloud<pcl::PointXYZ>::Ptr cloud, 
        pcl::PointCloud<pcl::PointXYZI>::Ptr keypoints,
        pcl::PointCloud<pcl::ShapeContext1980>::Ptr descriptors
    ) {
    // Compute normals
    pcl::PointCloud<pcl::Normal>::Ptr normals(new pcl::PointCloud<pcl::Normal>);
    pcl::NormalEstimation<pcl::PointXYZ, pcl::Normal> ne;
    ne.setInputCloud(cloud);
    ne.setRadiusSearch(0.1); // Adjust as needed
    ne.compute(*normals);

    // Harris Keypoint Detection
    pcl::HarrisKeypoint3D<pcl::PointXYZ, pcl::PointXYZI> harris;
    harris.setInputCloud(cloud);
    harris.setNormals(normals);
    harris.setNonMaxSupression(true); // pasar a TRUE si se encuentran demasiados
    harris.setRadius(0.1); // default 0.1, determina el tama√±o de los descriptores
    harris.setThreshold(0.01); // default 0.01, menor thr == mas kps
    harris.compute(*keypoints);

    // 3DSC Descriptor computation
    pcl::search::KdTree<pcl::PointXYZ>::Ptr tree(new pcl::search::KdTree<pcl::PointXYZ>);
    pcl::ShapeContext3DEstimation<pcl::PointXYZ, pcl::Normal, pcl::ShapeContext1980> sc3d;
    sc3d.setInputCloud(cloud);
    sc3d.setInputNormals(normals);
    sc3d.setSearchMethod(tree);
    sc3d.setRadiusSearch(0.1); // Adjust as needed
    sc3d.compute(*descriptors);
}

void (*)(pcl::PointCloud<pcl::PointXYZ>::Ptr, pcl::PointCloud<pcl::PointXYZI>::Ptr, pcl::PointCloud<pcl::ShapeContext1980>::Ptr
void (*)(boost::shared_ptr<pcl::PointCloud<pcl::PointXYZ> >, boost::shared_ptr<pcl::PointCloud<pcl::PointXYZI> >, boost::shared_ptr<pcl::PointCloud<pcl::ShapeContext1980> >)